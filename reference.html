<!DOCTYPE html>
<meta charset="utf-8" />
<title>dollcode</title>
<link rel="preconnect" href="https://fonts.bunny.net" />
<link href="https://fonts.bunny.net/css?family=atkinson-hyperlegible:400,400i,700,700i" rel="stylesheet" />

<style>
  :root {
    --top: #d9073b;
    --mid-top: #40b39a;
    --mid: #658e85;
    --mid-half: rgba(101, 142, 133, 0.5);
    --bottom: #0c100f;
    --floor: #040504;

    font-family: "Atkinson Hyperlegible", sans-serif;
    background-color: var(--bottom);
    color: #efefef;
  }

  section {
    padding: 2em;
  }

  #output {
    background-color: var(--floor);
    border: 1px solid var(--mid-half);
    display: inline-flex;
    margin: 4rem 0;
    padding: 3rem;
    font-size: 2em;
  }
</style>

<!-- Header -->
<section>
	<h1>dollcode generator</h1>
	<p>
		this is actually 2-track pharmacode but it doesn't give a shit about corpo names.
	</p>
</section>

<!-- Converter -->
<section>
  <p>input a number or dollcode</p>
  
	<!-- Input field for dec, hex, or dc -->
  <input type="string" id="id" value="41666" placeholder="41666" />
  <!-- Radio button for dec -->
	<input type="radio" id="decimal" name="radix" value="10" checked />
  <label for="decimal">Decimal (base10)</label>
  <!-- Radio button for hex, note the hex id -->
	<input type="radio" id="hex" name="radix" value="16" />
  <label for="hex">Hexadecimal (base16)</label>
  <!-- Radio button for dc -->
	<input type="radio" id="dollcode" name="radix" value="dollcode" />
  <label for="dollcode">dollcode</label>
  
	<!-- Text output -->
  <div>
    <div id="output">▖▘▌▘▘▌▌▌▖▘</div>
  </div>
</section>

<!-- Explanation -->
<section>
  <h2>what?</h2>
  <p>
    dollcode is a trinary number, with a ▖, ▘, ▌ denoting the three bit states, with most significant bit on the left side.
  </p>
  <p>
    if we were to count from 1 to 16, we would get ▖ ▘ ▌ ▖▖ ▖▘ ▖▌ ▘▖ ▘▘ ▘▌ ▌▖ ▌▘ ▌▌ ▖▖▖ ▖▖▘ ▖▖▌ ▖▘▖
  </p>
  <p>
    this is a simple case of looping through the number, and checking each modulus 3 section, and replacing it with one of the 3 characters.<br/><b>see source for the algo, it's simple.</b>
  </p>
</section>


<script>
  const charmap = ["▌", "▖", "▘"];
  
	// Generate dollcode
	
		// 'number' is the return from parseInt()
		// so the decimal representation of the input id
	const genCode = (number) => {
    const output = [];
		// Representation of the input number as the 'window' of which places to check
			// 1081699353
    let window = number;
    // Max length protection
		let loopProtection = 1000;

																	// originally > 0,
																	// but >= 1 makes more sense to me
		while (loopProtection > 0 && window >= 1) {
      // Modulous of current place
			const mod = window % 3;

			if (mod == 0) {
				// subtract 3 to ensure division is clean
				// divide by 3 to shift place
				console.log(`${window} %3 = ${mod} => ${charmap[mod]}`)
        window = (window - 3) / 3;
				console.log(window)
      }
			
			else {
				// subtract mod to ensure division is clean
				// divide by 3 to shift place
        console.log(`${window} %3 = ${mod} => ${charmap[mod]}`)
				window = (window - mod) / 3;
				console.log(window)
      }

			// Add according ▌▖▘ to beginning of output array based on the mod
			// If mod == 0, add ▌ becase perfectly divisible by 3
			output.unshift(charmap[mod]);
      	// arr.unshift adds to the beginning of the array
					// lookup character in charmap according to mod

      // Decrement max length
			loopProtection--;
    }

		// Return string from array
    console.log(output.join(""))
		return output.join("");
  };

  const parseDollcode = (dollcode) => {
    // reverse the nibs! [sic]
		// have to reverse the input code to build from the smallest place to largest
		// (1 > 3 > 9 > 27 > ...)
    const nibs = dollcode.trim().split("").reverse();
			// trim whitespace, split between characters, reverse the returned array

    console.log({ nibs });

    return nibs
			// map returns and array populated by the returns of calling a provided function on every item
			// return 1, 2, or 3 depending on nib
			// i.e. ["▖", "▘", "▌"] becomes [1, 2, 3]
      .map((nib) => (nib === "▖" ? 1 : nib === "▘" ? 2 : 3))
			// reduce calls a provided 'reducer' function sequnetially, passing the result of the previous into the next
      .reduce((acc, val, index) => {
					// acc   => accumulator  => resulting value of all previous calls
					// val   => currentValue => the value of the current item; always 1, 2, or 3
					// index => currentIndex => the position of currentValue in the away
        
				// value of the current place: [1,2,3] * 3^index
				const r = val * Math.pow(3, index);
        // return the new value to the next call of the reducer
				const res = r + acc;
        console.log({ acc, val, index, r, res });
        return res;
      }, 0);
			// extra 0 arg isnt required here, reduce can take 1 or 2 args
  };

	// Fill the output div
  const setOutput = (text) => {
    document.querySelector("#output").innerHTML = text;
  };

	// Check if 0x or 0d based on the state of the #hex radio button
  const getIDRadix = () => {
		// If hex is checked return 16, else return 10
    return document.querySelector("#hex").checked ? 16 : 10;
  };

	// Update whenever any input it changed, keyup, keypress (fixes mobile im guessing?), or keydown
  const updateEvent = () => {
		console.log('\n\n')
		
		// Value of input field
    const id = document.querySelector("#id").value;

		// If radio button for dollcode is selected
		// i.e. if the user is inputting dc
    if (document.querySelector("#dollcode").checked) {
      // Parse dc into a number
			const number = parseDollcode(id);
      console.log({ number });
      // Set the contents of the output to be ul containing 0d and 0x representations
			setOutput(
        `<ul>
					<li>dec: ${number.toString(10)}</li>
					<li>hex: ${number.toString(16)}</li>
				</ul>`
      );
    }
		// If 0d or 0x is selected, generate the dc
		else {
			// Parses a string depending on the radix*
			// i.e. parseInt('f', 16) => 15
			// getIDRadix returns 10 or 16 based on the state of the radio buttons
			const number = parseInt(id, getIDRadix());
      // Fill the output div with the returned dc
			setOutput(genCode(number));

			// * Radix is the number of digits to use, or base, or a number system
			// Decimal is radix 10, 0-9
			// Hex is radix 16, 0-f
			// etc
    }
  };

	// Update on changes to inputs
  document.querySelectorAll("input").forEach((x) => {
    x.addEventListener("change",   updateEvent);
    // x.addEventListener("keyup",    updateEvent);
    x.addEventListener("keypress", updateEvent);
    // x.addEventListener("keydown",  updateEvent);
  });
</script>
